from pydantic import BaseModel, Field, field_validator, constr
from typing import List, Optional, Dict, Union, Any, Annotated, Literal
from pydantic.types import PositiveInt
import time
import uuid


class TextContentPart(BaseModel):
    """Text content part for the chat completion."""
    text: str = Field(
        description="Text content of the part.",
    )
    type: Literal['text'] = Field(
        default='text',
        description="Type of the content part, currently only 'text' is supported.",
    )


class ImageURL(BaseModel):
    """Image URL for the chat completion."""
    url: str = Field(
        description="Either a URL of the image or the base64 encoded image data.",
    )
    detail: Optional[str] = Field(
        description="Description of the image.",
    )


class ImageContentPart(BaseModel):
    """Image content part for the chat completion."""
    image_url: ImageURL = Field(
        description="URL of the image content.",
    )
    type: Literal['image'] = Field(
        default='image',
        description="Type of the content part, currently only 'image' is supported.",
    )


class AudioData(BaseModel):
    """Audio data for the chat completion."""
    data: str = Field(
        description="Base64 encoded audio data.",
    )
    format: Literal['wav', 'mp3'] = Field(
        description="The format of the audio data, e.g., 'wav' or 'mp3'.",
    )


class AudioContentPart(BaseModel):
    """Audio content part for the chat completion."""
    input_audio: AudioData = Field(
        description="Audio data for the audio content.",
    )
    type: Literal['audio'] = Field(
        default='audio',
        description="Type of the content part, currently only 'audio' is supported.",
    )


class FileData(BaseModel):
    file_data: str = Field(
        description="Base64 encoded file data.",
    )
    file_id: Optional[str] = Field(
        default_factory=None,
        description="Unique identifier for the file.",
    )
    filename: Optional[str] = Field(
        default=None,
        description="Name of the file.",
    )


class FileContentPart(BaseModel):
    """File content part for the chat completion."""
    file: FileData = Field(
        description="File data for the file content.",
    )
    type: Literal['file'] = Field(
        default='file',
        description="Type of the content part, currently only 'file' is supported.",
    )


class RefusalContentPart(BaseModel):
    """Refusal content part for the chat completion."""
    refusal: str = Field(
        description="The refusal message generated by the model.",
    )
    type: Literal['refusal'] = Field(
        default='refusal',
        description="Type of the content part, currently only 'refusal' is supported.",
    )


SystemMessageContentPart = Union[TextContentPart]
UserMessageContentPart = Union[TextContentPart,
                               ImageContentPart, AudioContentPart, FileContentPart]
AssistantMessageContentPart = Union[TextContentPart, RefusalContentPart]
ToolMessageContentPart = Union[TextContentPart]


class DeveloperMessage(BaseModel):
    """Developer message for the chat completion."""
    content: str = Field(
        description="Content of the developer message.",
    )
    role: Literal['developer'] = Field(
        default='developer',
        description="Role of the author of this message.",
    )


class SystemMessage(BaseModel):
    """System message for the chat completion."""
    content: Union[str, List[SystemMessageContentPart]] = Field(
        description="Content of the system message.",
    )
    role: Literal['system'] = Field(
        default='system',
        description="Role of the author of this message.",
    )


class UserMessage(BaseModel):
    """User message for the chat completion."""
    content: Union[str, List[UserMessageContentPart]] = Field(
        description="Content of the user message.",
    )
    role: Literal['user'] = Field(
        default='user',
        description="Role of the author of this message.",
    )


class ToolCallFunction(BaseModel):
    """Function details for the tool call."""
    name: str = Field(
        description="Name of the function to be called.",
    )
    arguments:  str = Field(
        description="The arguments to call the function with, as generated by the model in JSON format.",
    )


class ToolCall(BaseModel):
    """Tool call made by the model."""
    id: str = Field(
        default_factory=lambda: 'tool-' + uuid.uuid4().hex,
        description="Unique identifier for the tool call.",
    )
    type: Literal['function'] = Field(
        description="The type of the tool. Currently, only function is supported.",
    )
    function: ToolCallFunction = Field(
        description="Function details if the type is 'function'.",
    )


class AssistantMessage(BaseModel):
    """Assistant message for the chat completion."""
    role: Literal['assistant'] = Field(
        default='assistant',
        description="Role of the author of this message.",
    )
    audio: Optional[Any] = Field(
        default=None,
        description="Data about the audio response from the model.",
    )
    content: Optional[Union[str, List[AssistantMessageContentPart]]] = Field(
        default=None,
        description="Content of the assistant message.",
    )
    refusal: Optional[str] = Field(
        default=None,
        description="The refusal message generated by the model.",
    )
    tool_calls: List[ToolCall] = Field(
        default_factory=list,
        description="List of tool calls made by the model.",
    )


class ToolMessage(BaseModel):
    """Tool message for the chat completion."""
    content: Union[str, List[ToolMessageContentPart]] = Field(
        description="Content of the tool message.",
    )
    role: Literal['tool'] = Field(
        default='tool',
        description="Role of the author of this message.",
    )
    tool_call_id: str = Field(
        description="Tool call that this message is responding to.",
    )


ChatCompletionMessages = Union[DeveloperMessage,
                               SystemMessage,
                               UserMessage,
                               AssistantMessage,
                               ToolMessage]


class TextResponseFormat(BaseModel):
    """Text response format for the chat completion."""
    type: Literal['text'] = Field(
        default='text',
        description="Type of the response format, currently only 'text' is supported.",
    )


class JsonSchema(BaseModel):
    """JSON schema for the chat completion."""
    name: str = Field(
        description="Name of the JSON schema.",
    )
    description: Optional[str] = Field(
        default=None,
        description="Description of the JSON schema.",
    )
    schema: Optional[Any] = Field(
        default=None,
        description="The JSON schema definition.",
    )
    strict: Optional[bool] = Field(
        default=None,
        description="Whether the schema is strict or not.",
    )


class JsonSchemaResponseFormat(BaseModel):
    """JSON response format for the chat completion."""
    type: Literal['json_schema'] = Field(
        default='json_schema',
        description="Type of the response format, currently only 'json_schema' is supported.",
    )
    json_schema: JsonSchema = Field(
        description="Schema of the JSON response.",
    )


class JsonResponseFormat(BaseModel):
    """JSON response format for the chat completion."""
    type: Literal['json'] = Field(
        default='json',
        description="Type of the response format, currently only 'json' is supported.",
    )


ResponseFormat = Union[TextResponseFormat,
                       JsonSchemaResponseFormat,
                       JsonResponseFormat]


class ToolChoiceFunctionOption(BaseModel):
    """Function option for tool choice."""
    name: str = Field(
        description="Name of the function.",
    )


class ToolChoiceOption(BaseModel):
    type: Literal['function'] = Field(
        default='function',
        description="Type of the tool choice option, currently only 'function' is supported.",
    )
    function: ToolChoiceFunctionOption = Field(
        description="Function details for the tool choice option.",
    )


class ToolFunctionParameterProperties(BaseModel):
    """Properties for the tool function parameters."""
    type: Literal['string', 'number', 'boolean', 'array', 'object'] = Field(
        description="Type of the property, e.g., 'string', 'number', etc.",
    )
    description: Optional[str] = Field(
        default=None,
        description="Description of the property.",
    )
    enum: Optional[List[Any]] = Field(
        default=None,
        description="List of allowed values for the property if applicable.",
    )


class ToolFunctionParameters(BaseModel):
    """Parameters for the tool function."""
    type: Literal['object'] = Field(
        default='object',
        description="Type of the parameters, currently only 'object' is supported.",
    )
    properties: Dict[str, ToolFunctionParameterProperties] = Field(
        description="Properties of the parameters in JSON schema format.",
    )


class ToolFunction(BaseModel):
    """Function available for the model to call."""
    name: str = Field(
        description="Name of the function.",
    )
    description: Optional[str] = Field(
        default=None,
        description="Description of the function.",
    )
    parameters: Optional[ToolFunctionParameters] = Field(
        default=None,
        description="Parameters for the function in JSON schema format.",
    )
    strict: Optional[bool] = Field(
        default=None,
        description="Whether the function parameters are strict or not.",
    )


class Tool(BaseModel):
    """Tool available for the model to call."""
    function: ToolFunction = Field(
        description="Function details for the tool.",
    )
    type: Literal['function'] = Field(
        default='function',
        description="Type of the tool, currently only 'function' is supported.",
    )


class ChatCompletionRequest(BaseModel):
    messages: List[ChatCompletionMessages] = Field(
        description="List of messages in the chat conversation.",
    )
    model: str = Field(
        description="The name of the model to use for the chat completion.",
    )
    audio: Optional[Any] = Field(
        default=None,
        description="Data about the audio response from the model.",
    )
    frequency_penalty: Optional[float] = Field(
        default=0.0,
        ge=-2.0, le=2.0,
        description="Penalty for frequency of tokens in the response.",
    )
    logprobs: Optional[bool] = Field(
        default=None,
        description="Whether to include log probabilities in the response.",
    )
    max_completion_tokens: Optional[PositiveInt] = Field(
        default=4096,
        description="The maximum number of tokens to generate in the response.",
    )
    n: Optional[PositiveInt] = Field(
        default=1,
        description="Number of completions to generate.",
    )
    parallel_tool_calls: Optional[bool] = Field(
        default=False,
        description="Whether to allow parallel tool calls.",
    )
    presence_penalty: Optional[float] = Field(
        default=0.0,
        ge=-2.0, le=2.0,
        description="Penalty for presence of tokens in the response.",
    )
    response_format: Optional[ResponseFormat] = Field(
        default=TextResponseFormat(),
        description="The format of the response.",
    )
    service_tier: Optional[Literal['auto']] = Field(
        default='auto',
        description="The service tier to use for the request.",
    )
    stop: Optional[Union[str, List[str]]] = Field(
        default=None,
        description="Stop sequences for the model to stop generating tokens.",
    )
    stream: Optional[bool] = Field(
        default=False,
        description="Whether to stream the response.",
    )
    stream_options: Optional[Any] = Field(
        default=None,
        description="Options for streaming the response.",
    )
    temperature: Optional[float] = Field(
        default=1.0,
        ge=0.0, le=2.0,
        description="Sampling temperature for the response.",
    )
    tool_choice: Optional[Union[Literal['auto', 'none'], ToolChoiceOption]] = Field(
        default='auto',
        description="Controls which (if any) tool is called by the model. ",
    )
    tools: Optional[List[Tool]] = Field(
        default=None,
        description="List of tools available for the model to call.",
    )
    top_p: Optional[float] = Field(
        default=1.0,
        ge=0.0, le=1.0,
        description="Nucleus sampling parameter for the response.",
    )
